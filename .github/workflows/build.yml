name: Auto Build function (Use for call only)
on:
  workflow_call:
    inputs:
      arch:
        type: string
      gapps:
        type: string
      root:
        type: string
      insider:
        type: string
      magiskver:
        type: string
      devicemodel:
        type: string
      amazonflag:
        type: string
      compressformat:
       type: string
      wsa_ver:
        type: string
      gappsver:
        type: string    
        
jobs:
  build:
    name: Build WSA
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ‚ôªÔ∏è
        uses: actions/checkout@v4

      - name: Setup Python üè≠
        uses: actions/setup-python@v5
        with:
          check-latest: true
          python-version: '3.x'
          cache: 'pip'
          cache-dependency-path: MagiskOnWSA/scripts/

      - name: Setup Python3 Virtual Enviroment üêç
        working-directory: MagiskOnWSA/scripts
        run: |
          sudo apt-get update
          PYTHON_VENV_DIR="$(dirname "$PWD")/python3-env"
          python3 -m venv "$PYTHON_VENV_DIR" || abort "Failed to create python3 virtual env"
          # shellcheck disable=SC1091
          source "$PYTHON_VENV_DIR/bin/activate" || abort "Failed to activate python3 virtual env"
          python3 -c "import pkg_resources; pkg_resources.require(open('requirements.txt',mode='r'))" &>/dev/null || {
              echo "Installing Python3 dependencies"
              python3 -m pip install --upgrade -r requirements.txt || abort "Failed to install python3 dependencies"
          }
          deactivate

      - name: Install Ubuntu Dependencies üßë‚Äçüè≠
        uses: awalsh128/cache-apt-pkgs-action@v1
        with:
          packages: e2fsprogs attr unzip qemu-utils python3-venv curl xmlstarlet
          version: 1.0

      - name: Check workflow inputs
        run: |
          echo ${{ inputs.arch }}
          echo ${{ inputs.gapps }}
          echo ${{ inputs.root }}
          echo ${{ inputs.insider }}
          echo ${{ inputs.magiskver }}
          echo ${{ inputs.devicemodel }}
          echo ${{ inputs.amazonflag }}
          echo ${{ inputs.compressformat }}
          echo ${{ inputs.release_type }}
          echo ${{ inputs.wsa_ver }}
          echo ${{ inputs.gappsver }}

      - name: Build WSA ${{ inputs.arch }} with GApps ${{ inputs.root }} üèóÔ∏è
        id: wsa
        working-directory: MagiskOnWSA
        run: |
          chmod -R 777 ./
          mkdir -p download
          ./scripts/build.sh --arch ${{ inputs.arch }} --release-type WIF --magisk-ver ${{ inputs.magiskver }} ${{ inputs.gapps }} --root-sol ${{ inputs.root }} ${{ inputs.amazonflag }} --compress-format none

      - name: Install Houdini and Process Images üîß
        working-directory: MagiskOnWSA
        run: |
          #!/bin/bash
          set -e
          
          # Define working directory and mount points
          WORK_DIR="$(pwd)"
          ROOT_MNT="$WORK_DIR/system_root_merged"
          SYSTEM_MNT="$ROOT_MNT/system"
          VENDOR_MNT="$ROOT_MNT/vendor"
          
          # Get the artifact folder from the build step
          ARTIFACT_FOLDER="${{ steps.wsa.outputs.artifact_folder }}"
          WSA_PATH="$WORK_DIR/output/$ARTIFACT_FOLDER"
          
          echo "Expand images"
          
          SYSTEM_IMG_SIZE=$(du --apparent-size -sB512 "$WSA_PATH/system.vhdx" | cut -f1)
          VENDOR_IMG_SIZE=$(du --apparent-size -sB512 "$WSA_PATH/vendor.vhdx" | cut -f1)
          
          # Convert vhdx to img for processing
          qemu-img convert -f vhdx -O raw "$WSA_PATH/system.vhdx" "$WSA_PATH/system.img"
          qemu-img convert -f vhdx -O raw "$WSA_PATH/vendor.vhdx" "$WSA_PATH/vendor.img"
          
          SYSTEM_IMG_SIZE=$(du --apparent-size -sB512 "$WSA_PATH/system.img" | cut -f1)
          VENDOR_IMG_SIZE=$(du --apparent-size -sB512 "$WSA_PATH/vendor.img" | cut -f1)
          
          SYSTEM_TARGET_SIZE=$((SYSTEM_IMG_SIZE * 3))
          # Calculate vendor size based on architecture and Houdini requirements
          if [ "${{ inputs.arch }}" = "x64" ]; then
              VENDOR_HOUDINI_SIZE=419430400  # 400MB in bytes for Houdini files
              VENDOR_EXTRA_SIZE=209715200    # 200MB extra buffer in bytes
              VENDOR_TOTAL_EXTRA=$((VENDOR_HOUDINI_SIZE + VENDOR_EXTRA_SIZE))
              VENDOR_TOTAL_EXTRA_BLOCKS=$((VENDOR_TOTAL_EXTRA / 512))  # Convert to 512-byte blocks
              VENDOR_TARGET_SIZE=$((VENDOR_IMG_SIZE + VENDOR_TOTAL_EXTRA_BLOCKS))
          else
              VENDOR_NEED_SIZE=209715200  # 200MB in bytes for non-x64
              VENDOR_NEED_BLOCKS=$((VENDOR_NEED_SIZE / 512))  # Convert to 512-byte blocks
              VENDOR_TARGET_SIZE=$((VENDOR_IMG_SIZE + VENDOR_NEED_BLOCKS))
          fi
          
          # Function to abort with error message
          abort() {
              echo "Error: $1"
              exit 1
          }
          
          # Function to resize image
          resize_img() {
              e2fsck -f -y "$1" || return 1
              if [ -n "$2" ]; then
                  truncate -s "$2" "$1" || return 1
                  resize2fs "$1" || return 1  # Expand to fill space
              else
                  resize2fs -M "$1" || return 1  # Minimize/shrink
              fi
              return 0
          }
          
          # Resize images (convert blocks to bytes for truncate)
          resize_img "$WSA_PATH/system.img" "$((SYSTEM_TARGET_SIZE * 512))" || abort "Failed to resize system.img"
          resize_img "$WSA_PATH/vendor.img" "$((VENDOR_TARGET_SIZE * 512))" || abort "Failed to resize vendor.img"
          
          echo -e "Expand images done\n"
          
          # Function to convert read-only EXT4 image to read-write (without shrinking after)
          ro_ext4_img_to_rw() {
              local img_file="$1"
              local current_size=$(du --apparent-size -sB512 "$img_file" | cut -f1)
              local temp_size=$((current_size * 2 * 512))
              
              # Temporarily expand for the conversion process
              resize_img "$img_file" "$temp_size" || return 1
              e2fsck -fp -E unshare_blocks "$img_file" || return 1
              
              # For vendor image with Houdini, preserve the allocated space
              if [[ "$img_file" == *"vendor.img" ]] && [ "${{ inputs.arch }}" = "x64" ]; then
                  # Resize back to our target size, not minimized
                  resize_img "$img_file" "$((VENDOR_TARGET_SIZE * 512))" || return 1
              else
                  # For system or non-Houdini vendor, minimize
                  resize_img "$img_file" || return 1
              fi
              return 0
          }
          
          echo "Remove read-only flag for read-only EXT4 image"
          ro_ext4_img_to_rw "$WSA_PATH/system.img" || echo "Failed to convert system.img to read-write"
          ro_ext4_img_to_rw "$WSA_PATH/vendor.img" || echo "Failed to convert vendor.img to read-write"
          echo -e "Remove read-only flag for read-only EXT4 image done\n"
          
          # Debug: Show actual file sizes after resize operations
          echo "Debug: File sizes after resize operations:"
          ls -lh "$WSA_PATH/system.img" "$WSA_PATH/vendor.img"
          
          echo "Mount images"
          
          sudo mkdir -p "$ROOT_MNT"
          sudo mount -t ext4 -o loop "$WSA_PATH/system.img" "$ROOT_MNT" || abort "Failed to mount system.img"
          sudo mount -t ext4 -o loop "$WSA_PATH/vendor.img" "$VENDOR_MNT" || abort "Failed to mount vendor.img"
          
          echo -e "Mount done\n"
          
          # Check available space before Houdini installation
          echo "Checking available space on mounted filesystems..."
          df -h "$ROOT_MNT" "$VENDOR_MNT"
          
          # Additional space verification for x64 builds
          if [ "${{ inputs.arch }}" = "x64" ]; then
              VENDOR_AVAIL_KB=$(df "$VENDOR_MNT" | tail -1 | awk '{print $4}')
              VENDOR_AVAIL_MB=$((VENDOR_AVAIL_KB / 1024))
              echo "Vendor partition available space: ${VENDOR_AVAIL_MB}MB"
              
              if [ "$VENDOR_AVAIL_MB" -lt 400 ]; then
                  echo "Warning: Vendor partition may not have enough space for Houdini files (400MB needed)"
                  echo "Attempting to remount with more space..."
                  
                  # Unmount and try to expand more
                  sudo umount "$VENDOR_MNT" || true
                  
                  # Add more space (additional 300MB)
                  ADDITIONAL_SPACE=$((314572800 / 512))  # 300MB in 512-byte blocks
                  NEW_VENDOR_TARGET=$((VENDOR_TARGET_SIZE + ADDITIONAL_SPACE))
                  resize_img "$WSA_PATH/vendor.img" "$((NEW_VENDOR_TARGET * 512))" || abort "Failed to expand vendor.img further"
                  
                  # Remount
                  sudo mount -t ext4 -o loop "$WSA_PATH/vendor.img" "$VENDOR_MNT" || abort "Failed to remount vendor.img"
                  
                  echo "After additional expansion:"
                  df -h "$VENDOR_MNT"
              fi
          fi
          
          # Install Houdini files only for x64 architecture using local files
          if [ "${{ inputs.arch }}" = "x64" ]; then
              echo "Installing Houdini files from local libhoudini folder (Many Thanks to SupremeGamers)"
              HOUDINI_LOCAL_PATH="$(realpath ./libhoudini)"
          
              # Verify local Houdini files exist
              if [ ! -d "$HOUDINI_LOCAL_PATH" ]; then
                  echo "Local Houdini directory not found at $HOUDINI_LOCAL_PATH, skipping Houdini installation"
              else
                  # Check total size of Houdini files to be copied
                  echo "Calculating total size of Houdini files..."
                  HOUDINI_SIZE=$(du -sh "$HOUDINI_LOCAL_PATH" | cut -f1)
                  echo "Total Houdini files size: $HOUDINI_SIZE"
                  
                  # Create necessary directories
                  sudo mkdir -p "$VENDOR_MNT/etc/binfmt_misc"
                  sudo mkdir -p "$VENDOR_MNT/lib"
                  sudo mkdir -p "$VENDOR_MNT/lib64"
                  sudo mkdir -p "$VENDOR_MNT/bin"
                  sudo mkdir -p "$SYSTEM_MNT/bin"
              
                  # Copy binfmt_misc files from local directory with error checking
                  echo "Copying binfmt_misc files from local directory..."
                  sudo cp "$HOUDINI_LOCAL_PATH/etc/binfmt_misc/arm64_dyn" "$VENDOR_MNT/etc/binfmt_misc/" || abort "Failed to copy arm64_dyn"
                  sudo cp "$HOUDINI_LOCAL_PATH/etc/binfmt_misc/arm64_exe" "$VENDOR_MNT/etc/binfmt_misc/" || abort "Failed to copy arm64_exe"
                  sudo cp "$HOUDINI_LOCAL_PATH/etc/binfmt_misc/arm_dyn" "$VENDOR_MNT/etc/binfmt_misc/" || abort "Failed to copy arm_dyn"
                  sudo cp "$HOUDINI_LOCAL_PATH/etc/binfmt_misc/arm_exe" "$VENDOR_MNT/etc/binfmt_misc/" || abort "Failed to copy arm_exe"
          
                  # Set SELinux properties for binfmt_misc files
                  sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$VENDOR_MNT/etc/binfmt_misc/arm64_dyn" || true
                  sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$VENDOR_MNT/etc/binfmt_misc/arm64_exe" || true
                  sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$VENDOR_MNT/etc/binfmt_misc/arm_dyn" || true
                  sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$VENDOR_MNT/etc/binfmt_misc/arm_exe" || true
          
                  # Copy vendor lib files from local directory with error checking
                  echo "Copying vendor library files from local directory..."
                  sudo cp "$HOUDINI_LOCAL_PATH/lib/libhoudini.so" "$VENDOR_MNT/lib/libhoudini.so" || abort "Failed to copy lib/libhoudini.so"
                  sudo cp "$HOUDINI_LOCAL_PATH/lib64/libhoudini.so" "$VENDOR_MNT/lib64/libhoudini.so" || abort "Failed to copy lib64/libhoudini.so"
          
                  # Set proper permissions and ownership for main libhoudini.so files
                  sudo chown root:root "$VENDOR_MNT/lib/libhoudini.so"
                  sudo chown root:root "$VENDOR_MNT/lib64/libhoudini.so"
                  sudo chmod 644 "$VENDOR_MNT/lib/libhoudini.so"
                  sudo chmod 644 "$VENDOR_MNT/lib64/libhoudini.so"
          
                  # Set SELinux properties for vendor lib files
                  sudo setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" "$VENDOR_MNT/lib/libhoudini.so" || true
                  sudo setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" "$VENDOR_MNT/lib64/libhoudini.so" || true
          
                  # Copy vendor bin files from local directory with error checking
                  echo "Copying vendor binary files from local directory..."
                  sudo cp "$HOUDINI_LOCAL_PATH/bin/houdini" "$VENDOR_MNT/bin/" || abort "Failed to copy bin/houdini"
                  sudo cp "$HOUDINI_LOCAL_PATH/bin/houdini64" "$VENDOR_MNT/bin/" || abort "Failed to copy bin/houdini64"
          
                  # Set SELinux properties for vendor bin files
                  sudo setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" "$VENDOR_MNT/bin/houdini" || true
                  sudo setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" "$VENDOR_MNT/bin/houdini64" || true
          
                  # Copy to system bin and set SELinux properties with error checking
                  echo "Copying to system bin..."
                  sudo cp "$HOUDINI_LOCAL_PATH/bin/houdini" "$SYSTEM_MNT/bin/" || abort "Failed to copy bin/houdini to system"
                  sudo cp "$HOUDINI_LOCAL_PATH/bin/houdini64" "$SYSTEM_MNT/bin/" || abort "Failed to copy bin/houdini64 to system"
          
                  # Set SELinux properties for system bin files
                  sudo setfattr -n security.selinux -v "u:object_r:system_file:s0" "$SYSTEM_MNT/bin/houdini" || true
                  sudo setfattr -n security.selinux -v "u:object_r:system_file:s0" "$SYSTEM_MNT/bin/houdini64" || true
          
                  # Set ownership and permissions for vendor bin files (root:2000, 755)
                  sudo chown root:2000 "$VENDOR_MNT/bin/houdini"
                  sudo chown root:2000 "$VENDOR_MNT/bin/houdini64"
                  sudo chmod 755 "$VENDOR_MNT/bin/houdini"
                  sudo chmod 755 "$VENDOR_MNT/bin/houdini64"
          
                  # Set ownership and permissions for system bin files (root:2000, 755)
                  sudo chown root:2000 "$SYSTEM_MNT/bin/houdini"
                  sudo chown root:2000 "$SYSTEM_MNT/bin/houdini64"
                  sudo chmod 755 "$SYSTEM_MNT/bin/houdini"
                  sudo chmod 755 "$SYSTEM_MNT/bin/houdini64"
          
                  # Copy ARM library files to vendor directories
                  echo "Copying ARM library files to vendor directories..."
                  sudo mkdir -p "$VENDOR_MNT/lib/arm"
                  sudo mkdir -p "$VENDOR_MNT/lib64/arm64"
                  
                  # Check available space before copying large ARM libraries
                  echo "Checking available space before copying ARM libraries..."
                  df -h "$VENDOR_MNT"
          
                  # Copy all ARM library files from libhoudini/lib64/arm64 to vendor/lib64/arm64
                  if [ -d "$HOUDINI_LOCAL_PATH/lib64/arm64" ]; then
                      echo "Copying ARM libraries to vendor/lib64/arm64..."
                      ARM64_SIZE=$(du -sh "$HOUDINI_LOCAL_PATH/lib64/arm64" 2>/dev/null | cut -f1 || echo "unknown")
                      echo "ARM64 libraries size: $ARM64_SIZE"
                      if [ "$(ls -A "$HOUDINI_LOCAL_PATH/lib64/arm64" 2>/dev/null)" ]; then
                          sudo cp -r "$HOUDINI_LOCAL_PATH/lib64/arm64/"* "$VENDOR_MNT/lib64/arm64/" || abort "Failed to copy ARM64 libraries to vendor/lib64/arm64"
                      else
                          echo "Warning: No files found in $HOUDINI_LOCAL_PATH/lib64/arm64"
                      fi
                      # Set permissions and ownership for all files in vendor/lib64/arm64
                      sudo find "$VENDOR_MNT/lib64/arm64" -type f -exec chown root:root {} \; 2>/dev/null || true
                      sudo find "$VENDOR_MNT/lib64/arm64" -type f -exec chmod 644 {} \; 2>/dev/null || true
                      # Set SELinux context for all files in vendor/lib64/arm64
                      sudo find "$VENDOR_MNT/lib64/arm64" -type f -exec setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" {} \; 2>/dev/null || echo "Warning: Failed to set SELinux context for some files in vendor/lib64/arm64"
                  else
                      echo "Warning: ARM64 library directory $HOUDINI_LOCAL_PATH/lib64/arm64 not found"
                  fi
          
                  # Copy all files from libhoudini/lib/arm to vendor/lib/arm
                  if [ -d "$HOUDINI_LOCAL_PATH/lib/arm" ]; then
                      echo "Copying ARM libraries from libhoudini/lib/arm to vendor/lib/arm..."
                      ARM_SIZE=$(du -sh "$HOUDINI_LOCAL_PATH/lib/arm" 2>/dev/null | cut -f1 || echo "unknown")
                      echo "ARM libraries size: $ARM_SIZE"
                      if [ "$(ls -A "$HOUDINI_LOCAL_PATH/lib/arm" 2>/dev/null)" ]; then
                          sudo cp -r "$HOUDINI_LOCAL_PATH/lib/arm/"* "$VENDOR_MNT/lib/arm/" || abort "Failed to copy ARM libraries to vendor/lib/arm"
                      else
                          echo "Warning: No files found in $HOUDINI_LOCAL_PATH/lib/arm"
                      fi
                      # Set permissions and ownership for all files in vendor/lib/arm
                      sudo find "$VENDOR_MNT/lib/arm" -type f -exec chown root:root {} \; 2>/dev/null || true
                      sudo find "$VENDOR_MNT/lib/arm" -type f -exec chmod 644 {} \; 2>/dev/null || true
                      # Set SELinux context for all files in vendor/lib/arm
                      sudo find "$VENDOR_MNT/lib/arm" -type f -exec setfattr -n security.selinux -v "u:object_r:same_process_hal_file:s0" {} \; 2>/dev/null || echo "Warning: Failed to set SELinux context for some files in vendor/lib/arm"
                  else
                      echo "Warning: ARM library directory $HOUDINI_LOCAL_PATH/lib/arm not found"
                  fi
          
                  # Edit init.windows_x86_64.rc to add Houdini exec commands after mount bind commands
                  echo "Editing init.windows_x86_64.rc for Houdini binary format registration..."
                  INIT_WINDOWS_RC="$VENDOR_MNT/etc/init/init.windows_x86_64.rc"
                  if [ -f "$INIT_WINDOWS_RC" ]; then
                      # Create a backup of the original file
                      sudo cp "$INIT_WINDOWS_RC" "$INIT_WINDOWS_RC.backup"
                      # Create a temporary file for the modifications
                      TEMP_RC="/tmp/init_windows_temp.rc"
                      # Process the file line by line to add exec commands after mount bind commands
                      sudo awk '
                      {
                          print $0
                          if ($0 ~ /mount none \/vendor\/bin\/houdini \/system\/bin\/houdini bind rec/) {
                              print "    exec -- /system/bin/sh -c \"echo '"'"':arm_exe:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x01\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x02\\\\x00\\\\x28::/system/bin/houdini:P'"'"' > /proc/sys/fs/binfmt_misc/register\""
                              print "    exec -- /system/bin/sh -c \"echo '"'"':arm_dyn:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x01\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\x28::/system/bin/houdini:P'"'"' >> /proc/sys/fs/binfmt_misc/register\""
                          }
                          if ($0 ~ /mount none \/vendor\/bin\/houdini64 \/system\/bin\/houdini64 bind rec/) {
                              print "    exec -- /system/bin/sh -c \"echo '"'"':arm64_exe:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x02\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x02\\\\x00\\\\xb7::/system/bin/houdini64:P'"'"' >> /proc/sys/fs/binfmt_misc/register\""
                              print "    exec -- /system/bin/sh -c \"echo '"'"':arm64_dyn:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x02\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\xb7::/system/bin/houdini64:P'"'"' >> /proc/sys/fs/binfmt_misc/register\""
                          }
                      }' "$INIT_WINDOWS_RC" > "$TEMP_RC"
                      # Replace the original file with the modified version
                      sudo mv "$TEMP_RC" "$INIT_WINDOWS_RC"
                      # Set proper SELinux context for the modified init file
                      sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$INIT_WINDOWS_RC" || true
                      sudo setfattr -n security.selinux -v "u:object_r:vendor_configs_file:s0" "$INIT_WINDOWS_RC.backup" || true
                      echo "Successfully updated init.windows_x86_64.rc with Houdini exec commands"
                  else
                      echo "Warning: init.windows_x86_64.rc not found at $INIT_WINDOWS_RC"
                  fi
                  
                  # Final space check after Houdini installation
                  echo "Final space check after Houdini installation:"
                  df -h "$VENDOR_MNT" "$SYSTEM_MNT"
                  echo "Houdini files installation completed successfully"
                  echo -e "Houdini files installation completed\n"
              fi
          else
              echo "Skipping Houdini installation for ${{ inputs.arch }} architecture (Houdini is only required for x64)"
          fi
          
          echo "Umount images"
          sudo find "$ROOT_MNT" -exec touch -hamt 200901010000.00 {} \; || true
          sudo umount -v "$VENDOR_MNT" || true
          sudo umount -v "$ROOT_MNT" || true
          echo -e "Umount done\n"
          
          echo "Shrink images"
          resize_img "$WSA_PATH/system.img" || abort "Failed to shrink system.img"
          
          # For vendor image with Houdini, don't minimize completely - keep some buffer space
          if [ "${{ inputs.arch }}" = "x64" ]; then
              echo "Preserving space in vendor.img for Houdini installation"
              # Calculate current used space and add 100MB buffer
              VENDOR_USED=$(du --apparent-size -sB512 "$WSA_PATH/vendor.img" | cut -f1)
              VENDOR_BUFFER=$((104857600 / 512))  # 100MB buffer in 512-byte blocks
              VENDOR_FINAL_SIZE=$((VENDOR_USED + VENDOR_BUFFER))
              resize_img "$WSA_PATH/vendor.img" "$((VENDOR_FINAL_SIZE * 512))" || abort "Failed to resize vendor.img with buffer"
          else
              resize_img "$WSA_PATH/vendor.img" || abort "Failed to shrink vendor.img"
          fi
          echo -e "Shrink images done\n"
          
          echo "Convert images back to vhdx"
          qemu-img convert -q -f raw -o subformat=fixed -O vhdx "$WSA_PATH/system.img" "$WSA_PATH/system.vhdx.new"
          qemu-img convert -q -f raw -o subformat=fixed -O vhdx "$WSA_PATH/vendor.img" "$WSA_PATH/vendor.vhdx.new"
          
          # Replace original vhdx files
          mv "$WSA_PATH/system.vhdx.new" "$WSA_PATH/system.vhdx"
          mv "$WSA_PATH/vendor.vhdx.new" "$WSA_PATH/vendor.vhdx"
          
          rm -f "$WSA_PATH/"*.img
          echo -e "Convert images to vhdx done\n"
        shell: bash

      - name: Check Subdirectories and Directories
        working-directory: MagiskOnWSA
        run: |
          ls -lR
          
      - name: Compress artifact for Windows 11 x64 Buildüì¶
        working-directory: MagiskOnWSA
        run: |
          7z a -t7z -mx=6 -m0=LZMA2 -ms=on -mmt=8 -- "${{ steps.wsa.outputs.artifact }}.7z" ./output/*

      - name: Run WSA Windows 10 Python Patch Script
        working-directory: MagiskOnWSA/output/${{ steps.wsa.outputs.artifact_folder }}
        run: |
          #!/bin/bash

          # Define the output directory
          outputDir="."

          # Define the namespaces
          rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
          desktop6="http://schemas.microsoft.com/appx/manifest/desktop/windows10/6"

          # Define the XML file
          xmlFile="$outputDir/AppxManifest.xml"

          # Patching Windows 10 AppxManifest file
          echo -e "\nPatching Windows 10 AppxManifest file..."

          # Remove the 'customInstallActions' Capability node
          xmlstarlet ed --inplace --delete "//*[local-name()='Capability' and @Name='customInstallActions']" $xmlFile

          # Remove the 'windows.customInstall' Extension node
          xmlstarlet ed --inplace --delete "//*[local-name()='Extension' and @Category='windows.customInstall']" $xmlFile

          # Update the MinVersion
          xmlstarlet ed --inplace --update "//*[local-name()='TargetDeviceFamily']/@MinVersion" -v "10.0.19041.264" $xmlFile

          # Downloading modified DLL file
          echo -e "\nDownloading modified DLL file..."

          # Download the DLL files
          curl -sL "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/winhttp.dll" -o "$outputDir/WsaClient/winhttp.dll"
          curl -sL "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/WsaPatch.dll" -o "$outputDir/WsaClient/WsaPatch.dll"
          curl -sL "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/icu.dll" -o "$outputDir/WsaClient/icu.dll"
        shell: bash

      - name: Compress artifact for Windows 10 x64 Buildüì¶
        working-directory: MagiskOnWSA
        run: 7z a -t7z -mx=6 -m0=LZMA2 -ms=on -mmt=8 -sdel -- "${{ steps.wsa.outputs.artifact }}_Windows_10.7z" ./output/*
      
      - name: Prepare release tag üè∑Ô∏è
        id: releasetag
        run: |
          currentver=${{ inputs.wsa_ver }}
          folderpath="/WSABuilds/Builds/Windows Subsystem For Android‚Ñ¢ v$currentver/Windows 11/Windows 11 x86_64"
          folderpathwin10="/WSABuilds/Builds/Windows Subsystem For Android‚Ñ¢ v$currentver/Windows 10/" 
          echo "DRIVE_FOLDER_PATH=$folderpath" >> $GITHUB_ENV  
          echo "DRIVE_FOLDER_PATH_WIN10=$folderpathwin10" >> $GITHUB_ENV 
          echo "WSA_TAG=Windows_11_$currentver" >> $GITHUB_ENV
          echo "WSA_TAG_WIN10=Windows_10_$currentver" >> $GITHUB_ENV
          echo "WSA_VER=$currentver" >> $GITHUB_ENV 

      - name: Check GitHub ENV variables
        run: |
          echo "${{ steps.wsa.outputs.artifact }}"
          echo "${{ steps.wsa.outputs.artifact_folder }}"
          echo "${{ steps.date.outputs.date }}"
          echo "${{ steps.wsa.outputs.built }}"
          echo "${{ env.WSA_TAG }}"
          echo "${{ env.WSA_VER }}"
          echo "${{ env.DRIVE_FOLDER_PATH }}"

      - name: Check Subdirectories and Directories
        working-directory: MagiskOnWSA
        run: |
          ls -lR

      - name: Upload Windows 11 x64 build to release ü§å
        uses: softprops/action-gh-release@v2
        with:
          files: MagiskOnWSA/${{ steps.wsa.outputs.artifact }}.7z
          fail_on_unmatched_files: true
          append_body: false
          tag_name: ${{ env.WSA_TAG }}
          token: ${{ secrets.GITHUB_TOKEN }}
            
      - name: Upload Windows 10 x64 build to release ü§å
        uses: softprops/action-gh-release@v2
        with:
          files: MagiskOnWSA/${{ steps.wsa.outputs.artifact }}_Windows_10.7z
          fail_on_unmatched_files: true
          append_body: false
          tag_name: ${{ env.WSA_TAG_WIN10 }}
          token: ${{ secrets.GITHUB_TOKEN }}

#     - name: Pass to Windows üí∏
#       uses: actions/upload-artifact@v4
#       with:
#         name: ${{ steps.wsa.outputs.artifact }}-${{ steps.wsa.outputs.built }}
#         path: MagiskOnWSA/output

#    outputs:
#      zipname: ${{ steps.wsa.outputs.artifact }}
#      artifact_folder: ${{ steps.wsa.outputs.artifact_folder }}
#      date: ${{ steps.date.outputs.date }}
#      built: ${{ steps.wsa.outputs.built }}
#      tag: ${{ env.WSA_TAG }}
#      tagwin10: ${{ env.WSA_TAG_WIN10 }}
#      wsaver: ${{ env.WSA_VER }}
#     onedrivepath: ${{ env.DRIVE_FOLDER_PATH }}
#      onedrivepathwin10: ${{ env.DRIVE_FOLDER_PATH_WIN10 }}

#  make-pri:
#    name: Merge PRI resources
#    runs-on: windows-latest
#    needs: build
#    steps:
#      - name: Checkout ‚ôªÔ∏è
#        uses: actions/checkout@v4
#
#      - name: Download built artifact ‚åõ
#        uses: actions/download-artifact@v4
#        with:
#          path: output
#          name: ${{ needs.build.outputs.zipname }}-${{ needs.build.outputs.built }}
#
#      - name: Remove unused artifact ‚ùå
#        uses: geekyeggo/delete-artifact@v5
#        with:
#          name: ${{ needs.build.outputs.zipname }}-${{ needs.build.outputs.built }}
#
#      - name: Check Subdirectories and Directories 1
#        run: tree /F ${{ github.workspace }}
#
#      - name: Check Subdirectories and Directories 2
#        run: tree /F "${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}"
#
#      - name: Merge language and density resources üßôüèª‚Äç‚ôÇÔ∏è
#        run: |
#          if ("${{ inputs.arch }}" -eq "x64") {
#            (Start-Process pwsh.exe -NoNewWindow -PassThru -Args "-ExecutionPolicy Bypass -File MakePri.ps1" -WorkingDirectory "${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}").WaitForExit()
#          } else {
#            Copy-Item -Force "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\arm64\makepri.exe" "${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}"
#          }
          
#      - name: Compact Images üíø
#        run: |
#         foreach ($Partition in 'system','product','system_ext','vendor') {
#             Write-Output "Optimizing of $Partition..."
#             Write-Output "SELECT VDISK FILE=`"${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}\$Partition.vhdx`"`
#             ATTACH VDISK READONLY`
#             COMPACT VDISK`
#             DETACH VDISK" | Set-Content -Path "$Partition.txt" -Encoding Ascii
#             Start-Process -NoNewWindow -Wait "diskpart.exe" -Args "/s $Partition.txt" -RedirectStandardOutput NUL
#         }

#      - name: Compress artifact for Windows 11 x64 Buildüì¶
#        run: 7z a -t7z -mx=6 -m0=LZMA2 -ms=on -mmt=8 -- "${{ needs.build.outputs.zipname }}.7z" .\output\*

#      - name: Setup rclone üéöÔ∏è
#        uses: AnimMouse/setup-rclone@v1.9.0
#        with:
#             rclone_config: ${{ secrets.RCLONE_CONFIG }}
#
#      - name: Upload build to OneDrive for Windows 11 x64 Build‚è´
#        run: |
#           echo ${{ needs.build.outputs.onedrivepath }}
#           rclone copy ${{ needs.build.outputs.zipname }}.7z OneDrive:"${{ needs.build.outputs.onedrivepath }}" --create-empty-src-dirs
#        env:
#           RCLONE_CONFIG_PASS: ${{ secrets.RCLONE_CONFIG_PASS }}

#      - name: Upload Windows 11 x64 build to release ü§å
#        uses: softprops/action-gh-release@v2
#        with:
#          files: ${{ needs.build.outputs.zipname }}.7z
#          fail_on_unmatched_files: true
#          append_body: false
#          tag_name: ${{ needs.build.outputs.tag }}
#          token: ${{ secrets.GITHUB_TOKEN }}

#      - name: Check Subdirectories and Directories 3
#        run: tree /F ${{ github.workspace }}

#      - name: Check Subdirectories and Directories 4
#        run: tree /F "${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}"
        
#      - name: Run WSA Windows 10 PowerShell Patch Script
#        run: |
#          Write-Output "`r`nPatching Windows 10 AppxManifest file..."
#          $outputDir = "${{ github.workspace }}\output\${{ needs.build.outputs.artifact_folder }}"
#          $xml = [xml](Get-Content "$outputDir\AppxManifest.xml")
#          $nsm = New-Object Xml.XmlNamespaceManager($xml.NameTable)
#          $nsm.AddNamespace('rescap', "http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities")
#          $nsm.AddNamespace('desktop6', "http://schemas.microsoft.com/appx/manifest/desktop/windows10/6")
#          $node = $xml.Package.Capabilities.SelectSingleNode("rescap:Capability[@Name='customInstallActions']", $nsm)
#          $xml.Package.Capabilities.RemoveChild($node) | Out-Null
#          $node = $xml.Package.Extensions.SelectSingleNode("desktop6:Extension[@Category='windows.customInstall']", $nsm)
#          $xml.Package.Extensions.RemoveChild($node) | Out-Null
#          $xml.Package.Dependencies.TargetDeviceFamily.MinVersion = "10.0.19041.264"
#          $xml.Save("$outputDir\AppxManifest.xml")
#          Write-Output "`r`nDownloading modifided DLL file..."
#          $ProgressPreference = 'SilentlyContinue'
#          Invoke-WebRequest -Uri "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/winhttp.dll" -OutFile "$outputDir\WSAClient\winhttp.dll"
#          Invoke-WebRequest -Uri "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/WsaPatch.dll" -OutFile "$outputDir\WSAClient\WsaPatch.dll"
#          Invoke-WebRequest -Uri "https://github.com/MustardChef/WSAPatch/raw/main/DLLs%20for%20WSABuilds/icu.dll" -OutFile "$outputDir\WSAClient\icu.dll"
#        shell: pwsh

#      - name: Compress artifact for Windows 10 x64 Buildüì¶
#        run: 7z a -t7z -mx=6 -m0=LZMA2 -ms=on -mmt=8 -sdel -- "${{ needs.build.outputs.zipname }}_Windows_10.7z" .\output\*

#      - name: Upload build to OneDrive for Windows 10 x64 Build‚è´
#        run: |
#              echo ${{ needs.build.outputs.onedrivepathwin10 }}
#              rclone copy ${{ needs.build.outputs.zipname }}_Windows_10.7z OneDrive:"${{ needs.build.outputs.onedrivepathwin10 }}" --create-empty-src-dirs
#        env:
#           RCLONE_CONFIG_PASS: ${{ secrets.RCLONE_CONFIG_PASS }}
        
#      - name: Upload Windows 10 x64 build to release ü§å
#        uses: softprops/action-gh-release@v2
#        with:
#          files: ${{ needs.build.outputs.zipname }}_Windows_10.7z
#          fail_on_unmatched_files: true
#          append_body: false
#          tag_name: ${{ needs.build.outputs.tagwin10 }}
#          token: ${{ secrets.GITHUB_TOKEN }}
